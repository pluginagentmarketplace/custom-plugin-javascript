# Modern JavaScript (ES6+) Features Reference
# Complete guide to ECMAScript 2015 and beyond

# ES6 (ES2015) Features
es2015:
  let_const:
    description: "Block-scoped variable declarations"
    examples:
      let: |
        let count = 0;
        count = 1;  // Reassignable

        // Block scoped
        if (true) {
          let x = 10;
        }
        // x is not defined here
      const: |
        const PI = 3.14159;
        // PI = 3; // Error: Assignment to constant

        // Object properties can change
        const obj = { a: 1 };
        obj.a = 2;  // OK
        obj.b = 3;  // OK
        // obj = {}; // Error
    best_practice: "Use const by default, let when reassignment needed"

  arrow_functions:
    description: "Concise function syntax with lexical this"
    syntax:
      basic: "(param) => expression"
      multi_param: "(a, b) => a + b"
      block_body: "(a) => { return a * 2; }"
      object_return: "(a) => ({ value: a })"
    examples:
      simple: |
        const double = x => x * 2;
        const add = (a, b) => a + b;
        const greet = name => `Hello, ${name}!`;
      lexical_this: |
        class Counter {
          constructor() {
            this.count = 0;
          }
          start() {
            // Arrow preserves 'this' from enclosing scope
            setInterval(() => {
              this.count++;  // 'this' refers to Counter instance
            }, 1000);
          }
        }
    when_not_to_use:
      - "Object methods (use regular functions)"
      - "When you need 'arguments' object"
      - "When you need dynamic 'this'"
      - "Constructors (arrow functions can't be used with 'new')"

  template_literals:
    description: "Multi-line strings with embedded expressions"
    syntax: "`string ${expression}`"
    examples:
      interpolation: |
        const name = 'World';
        const greeting = `Hello, ${name}!`;
      multi_line: |
        const html = `
          <div class="card">
            <h1>${title}</h1>
            <p>${content}</p>
          </div>
        `;
      expressions: |
        const price = `Total: $${(quantity * unitPrice).toFixed(2)}`;
      tagged: |
        function highlight(strings, ...values) {
          return strings.reduce((acc, str, i) =>
            `${acc}${str}<mark>${values[i] || ''}</mark>`, '');
        }
        const result = highlight`Hello ${name}, you have ${count} messages`;

  destructuring:
    description: "Extract values from arrays/objects into variables"
    examples:
      array: |
        const [a, b, c] = [1, 2, 3];
        const [first, ...rest] = [1, 2, 3, 4]; // rest = [2,3,4]
        const [x, , z] = [1, 2, 3]; // Skip elements
      object: |
        const { name, age } = { name: 'John', age: 30 };
        const { name: userName } = user; // Rename
        const { address: { city } } = user; // Nested
      defaults: |
        const { name = 'Anonymous' } = {};
        const [first = 0] = [];
      function_params: |
        function greet({ name, greeting = 'Hello' }) {
          return `${greeting}, ${name}!`;
        }
        greet({ name: 'World' });

  spread_rest:
    description: "Spread arrays/objects, collect rest parameters"
    examples:
      spread_array: |
        const arr1 = [1, 2, 3];
        const arr2 = [...arr1, 4, 5]; // [1,2,3,4,5]
        const copy = [...arr1]; // Shallow copy
      spread_object: |
        const obj1 = { a: 1, b: 2 };
        const obj2 = { ...obj1, c: 3 }; // { a:1, b:2, c:3 }
        const merged = { ...obj1, ...obj2 }; // Merge
      rest_params: |
        function sum(...numbers) {
          return numbers.reduce((a, b) => a + b, 0);
        }
        sum(1, 2, 3, 4); // 10

  default_parameters:
    description: "Default values for function parameters"
    syntax: "function fn(a = defaultValue)"
    examples:
      basic: |
        function greet(name = 'World') {
          return `Hello, ${name}!`;
        }
      expressions: |
        function createUser(name, role = getDefaultRole()) {
          return { name, role };
        }
      destructuring: |
        function fetch({ url, method = 'GET', body = null } = {}) {
          // ...
        }

  classes:
    description: "Syntactic sugar for prototype-based inheritance"
    examples:
      basic: |
        class Animal {
          constructor(name) {
            this.name = name;
          }

          speak() {
            console.log(`${this.name} makes a sound`);
          }
        }
      inheritance: |
        class Dog extends Animal {
          constructor(name, breed) {
            super(name);
            this.breed = breed;
          }

          speak() {
            console.log(`${this.name} barks`);
          }
        }
      static_methods: |
        class MathUtils {
          static add(a, b) {
            return a + b;
          }
        }
        MathUtils.add(1, 2);
      getters_setters: |
        class Circle {
          constructor(radius) {
            this._radius = radius;
          }

          get diameter() {
            return this._radius * 2;
          }

          set diameter(d) {
            this._radius = d / 2;
          }
        }

  modules:
    description: "Native module system"
    examples:
      named_export: |
        // utils.js
        export const PI = 3.14159;
        export function add(a, b) { return a + b; }

        // main.js
        import { PI, add } from './utils.js';
      default_export: |
        // User.js
        export default class User { ... }

        // main.js
        import User from './User.js';
      mixed: |
        // api.js
        export default function fetch() { ... }
        export const BASE_URL = 'https://api.example.com';

        // main.js
        import fetch, { BASE_URL } from './api.js';
      rename: |
        import { add as sum } from './math.js';
        import * as math from './math.js';

  promises:
    description: "Asynchronous operation handling"
    examples:
      basic: |
        const promise = new Promise((resolve, reject) => {
          setTimeout(() => resolve('Done!'), 1000);
        });

        promise.then(result => console.log(result));
      chaining: |
        fetch('/api/user')
          .then(response => response.json())
          .then(user => fetch(`/api/posts/${user.id}`))
          .then(response => response.json())
          .catch(error => console.error(error));
      static_methods: |
        Promise.all([fetch1, fetch2, fetch3]);
        Promise.race([timeout, actualWork]);
        Promise.resolve(value);
        Promise.reject(error);

  enhanced_objects:
    description: "Shorthand property/method syntax"
    examples:
      property_shorthand: |
        const name = 'John';
        const age = 30;
        const user = { name, age }; // { name: 'John', age: 30 }
      method_shorthand: |
        const obj = {
          greet() {
            return 'Hello!';
          }
        };
      computed_properties: |
        const key = 'dynamicKey';
        const obj = {
          [key]: 'value',
          [`prefix_${key}`]: 'prefixed'
        };

  symbols:
    description: "Unique, immutable identifiers"
    examples:
      basic: |
        const sym1 = Symbol('description');
        const sym2 = Symbol('description');
        sym1 === sym2; // false - always unique
      well_known: |
        // Built-in symbols
        Symbol.iterator  // Make object iterable
        Symbol.toStringTag  // Customize Object.prototype.toString
        Symbol.hasInstance  // Customize instanceof

  iterators_generators:
    description: "Custom iteration protocols"
    examples:
      iterator: |
        const iterable = {
          [Symbol.iterator]() {
            let i = 0;
            return {
              next() {
                return i < 3
                  ? { value: i++, done: false }
                  : { done: true };
              }
            };
          }
        };
      generator: |
        function* range(start, end) {
          for (let i = start; i <= end; i++) {
            yield i;
          }
        }

        for (const n of range(1, 5)) {
          console.log(n); // 1, 2, 3, 4, 5
        }

# ES2016 (ES7)
es2016:
  includes:
    description: "Check if array contains element"
    syntax: "array.includes(element, fromIndex)"
    example: |
      [1, 2, 3].includes(2);     // true
      [1, 2, 3].includes(4);     // false
      [1, NaN].includes(NaN);    // true (unlike indexOf)

  exponentiation:
    description: "Power operator"
    syntax: "base ** exponent"
    example: |
      2 ** 3;     // 8
      10 ** -1;   // 0.1
      2 ** 0.5;   // 1.4142... (square root)

# ES2017 (ES8)
es2017:
  async_await:
    description: "Syntactic sugar for Promises"
    examples:
      basic: |
        async function fetchUser(id) {
          const response = await fetch(`/api/users/${id}`);
          const user = await response.json();
          return user;
        }
      error_handling: |
        async function safeFetch(url) {
          try {
            const response = await fetch(url);
            return await response.json();
          } catch (error) {
            console.error('Fetch failed:', error);
            return null;
          }
        }
      parallel: |
        const [users, posts] = await Promise.all([
          fetchUsers(),
          fetchPosts()
        ]);

  object_entries_values:
    description: "Get entries/values from objects"
    examples:
      entries: |
        const obj = { a: 1, b: 2 };
        Object.entries(obj); // [['a', 1], ['b', 2]]

        // Iterate
        for (const [key, value] of Object.entries(obj)) {
          console.log(`${key}: ${value}`);
        }
      values: |
        Object.values({ a: 1, b: 2 }); // [1, 2]
      from_entries: |
        // ES2019
        Object.fromEntries([['a', 1], ['b', 2]]); // { a: 1, b: 2 }

  string_padding:
    description: "Pad strings to specified length"
    examples:
      padStart: |
        '5'.padStart(3, '0');   // '005'
        '42'.padStart(5, ' ');  // '   42'
      padEnd: |
        'hi'.padEnd(5, '!');    // 'hi!!!'

# ES2018 (ES9)
es2018:
  rest_spread_objects:
    description: "Rest/spread for objects"
    examples:
      rest: |
        const { a, ...rest } = { a: 1, b: 2, c: 3 };
        // a = 1, rest = { b: 2, c: 3 }
      spread: |
        const merged = { ...obj1, ...obj2 };

  async_iteration:
    description: "Async iterators and for-await-of"
    example: |
      async function* asyncGenerator() {
        yield await fetchPage(1);
        yield await fetchPage(2);
      }

      for await (const page of asyncGenerator()) {
        console.log(page);
      }

  promise_finally:
    description: "Finally handler for Promises"
    example: |
      fetch('/api/data')
        .then(response => response.json())
        .catch(error => console.error(error))
        .finally(() => {
          hideLoading();  // Always runs
        });

# ES2019 (ES10)
es2019:
  flat_flatMap:
    description: "Flatten nested arrays"
    examples:
      flat: |
        [1, [2, [3]]].flat();      // [1, 2, [3]]
        [1, [2, [3]]].flat(2);     // [1, 2, 3]
        [1, [2, [3]]].flat(Infinity); // [1, 2, 3]
      flatMap: |
        [1, 2, 3].flatMap(x => [x, x * 2]);
        // [1, 2, 2, 4, 3, 6]

  optional_catch:
    description: "Catch without parameter"
    example: |
      try {
        JSON.parse(invalid);
      } catch {
        console.log('Parse failed');
      }

  trimStart_trimEnd:
    description: "Trim whitespace from specific side"
    example: |
      '  hello  '.trimStart(); // 'hello  '
      '  hello  '.trimEnd();   // '  hello'

# ES2020 (ES11)
es2020:
  optional_chaining:
    description: "Safe property access"
    syntax: "obj?.prop, obj?.[expr], func?.()"
    examples:
      property: |
        const city = user?.address?.city;
        // Returns undefined if any part is null/undefined
      method: |
        const result = obj.method?.();
      array: |
        const first = arr?.[0];

  nullish_coalescing:
    description: "Default for null/undefined only"
    syntax: "value ?? defaultValue"
    examples:
      basic: |
        const name = user.name ?? 'Anonymous';
        // Only uses default for null/undefined

        0 ?? 1;          // 0
        '' ?? 'default'; // ''
        null ?? 'fallback'; // 'fallback'
      vs_or: |
        // || treats 0, '', false as falsy
        0 || 1;  // 1
        0 ?? 1;  // 0

  bigint:
    description: "Arbitrary precision integers"
    syntax: "123n or BigInt(123)"
    example: |
      const big = 9007199254740991n;
      big + 1n; // 9007199254740992n

      // Cannot mix with regular numbers
      // big + 1; // TypeError

  promise_allSettled:
    description: "Wait for all promises regardless of outcome"
    example: |
      const results = await Promise.allSettled([
        fetch('/api/1'),
        fetch('/api/2'),
        fetch('/api/3')
      ]);

      results.forEach(result => {
        if (result.status === 'fulfilled') {
          console.log('Success:', result.value);
        } else {
          console.log('Failed:', result.reason);
        }
      });

  globalThis:
    description: "Universal global object reference"
    example: |
      // Works in browser, Node, Web Workers
      globalThis.setTimeout(fn, 1000);

# ES2021 (ES12)
es2021:
  logical_assignment:
    description: "Logical operators with assignment"
    examples:
      or_assign: |
        x ||= y;  // x = x || y
        obj.prop ||= 'default';
      and_assign: |
        x &&= y;  // x = x && y
      nullish_assign: |
        x ??= y;  // x = x ?? y
        // Only assigns if x is null/undefined

  numeric_separators:
    description: "Underscores in numeric literals"
    example: |
      const billion = 1_000_000_000;
      const bytes = 0xFF_FF_FF_FF;
      const bits = 0b1010_0001;

  replaceAll:
    description: "Replace all occurrences in string"
    example: |
      'hello hello'.replaceAll('hello', 'hi'); // 'hi hi'

  promise_any:
    description: "First fulfilled promise"
    example: |
      const first = await Promise.any([
        fetch('/api/fast'),
        fetch('/api/slow'),
        fetch('/api/backup')
      ]);
      // Returns first to fulfill, ignores rejections

# ES2022 (ES13)
es2022:
  class_fields:
    description: "Public and private class fields"
    example: |
      class User {
        // Public field
        name = 'Anonymous';

        // Private field
        #password;

        // Static field
        static count = 0;

        constructor(password) {
          this.#password = password;
          User.count++;
        }

        // Private method
        #validate() {
          return this.#password.length >= 8;
        }
      }

  top_level_await:
    description: "await outside async functions (modules)"
    example: |
      // In ES module
      const config = await fetch('/config.json').then(r => r.json());
      export default config;

  at_method:
    description: "Relative indexing for arrays/strings"
    example: |
      const arr = [1, 2, 3, 4, 5];
      arr.at(0);   // 1
      arr.at(-1);  // 5 (last element)
      arr.at(-2);  // 4

      'hello'.at(-1); // 'o'

  object_hasOwn:
    description: "Better Object.hasOwnProperty"
    example: |
      Object.hasOwn({ a: 1 }, 'a'); // true
      Object.hasOwn({ a: 1 }, 'b'); // false

      // Works with null prototype objects
      const obj = Object.create(null);
      Object.hasOwn(obj, 'key'); // false

# ES2023 (ES14)
es2023:
  array_findLast:
    description: "Find from end of array"
    example: |
      const arr = [1, 2, 3, 4, 5];
      arr.findLast(n => n % 2 === 0);      // 4
      arr.findLastIndex(n => n % 2 === 0); // 3

  array_toSorted_toReversed:
    description: "Non-mutating array methods"
    example: |
      const arr = [3, 1, 2];

      // Original unchanged
      arr.toSorted();   // [1, 2, 3]
      arr.toReversed(); // [2, 1, 3]
      arr.toSpliced(1, 1); // [3, 2]
      arr.with(0, 99);  // [99, 1, 2]

      arr; // Still [3, 1, 2]

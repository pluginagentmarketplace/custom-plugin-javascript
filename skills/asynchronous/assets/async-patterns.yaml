# JavaScript Async Patterns Reference
# Complete guide to asynchronous programming patterns

# Core Concepts
core_concepts:
  event_loop:
    description: "JavaScript's single-threaded event loop model"
    components:
      - call_stack: "Executes synchronous code"
      - task_queue: "Callbacks from setTimeout, events"
      - microtask_queue: "Promise callbacks, queueMicrotask"
    execution_order:
      - "1. Execute all synchronous code (call stack)"
      - "2. Execute all microtasks (Promise callbacks)"
      - "3. Execute one task (setTimeout callback)"
      - "4. Repeat from step 2"

  callback:
    description: "Function passed as argument to be called later"
    pattern: "fn(arg, (error, result) => {})"
    problems:
      - "Callback hell (pyramid of doom)"
      - "Error handling scattered"
      - "Difficult to compose"

  promise:
    description: "Object representing eventual completion or failure"
    states:
      - pending: "Initial state"
      - fulfilled: "Operation completed successfully"
      - rejected: "Operation failed"
    pattern: "new Promise((resolve, reject) => {})"

  async_await:
    description: "Syntactic sugar over Promises"
    pattern: "async function() { await promise }"
    benefits:
      - "Synchronous-looking code"
      - "Try/catch for errors"
      - "Easier to debug"

# Promise Patterns
promise_patterns:
  basic_creation:
    example: |
      const promise = new Promise((resolve, reject) => {
        // Async operation
        if (success) {
          resolve(result);
        } else {
          reject(new Error('Failed'));
        }
      });

  chaining:
    example: |
      fetchUser(userId)
        .then(user => fetchPosts(user.id))
        .then(posts => renderPosts(posts))
        .catch(error => showError(error))
        .finally(() => hideLoader());
    notes:
      - "Each .then returns a new Promise"
      - ".catch catches errors from any previous step"
      - ".finally runs regardless of success/failure"

  parallel_execution:
    Promise_all:
      description: "Wait for all promises (fail-fast)"
      example: |
        const results = await Promise.all([
          fetch('/api/users'),
          fetch('/api/posts'),
          fetch('/api/comments')
        ]);
      behavior: "Rejects immediately if any promise rejects"

    Promise_allSettled:
      description: "Wait for all promises (no fail-fast)"
      example: |
        const results = await Promise.allSettled([
          fetch('/api/users'),
          fetch('/api/posts')
        ]);
        // [{status: 'fulfilled', value: ...}, {status: 'rejected', reason: ...}]
      behavior: "Always resolves with array of outcomes"

    Promise_race:
      description: "Resolve/reject with first settled promise"
      example: |
        const result = await Promise.race([
          fetch('/api/data'),
          timeout(5000)
        ]);
      use_case: "Implement timeouts"

    Promise_any:
      description: "Resolve with first fulfilled promise"
      example: |
        const result = await Promise.any([
          fetchFromCDN1(),
          fetchFromCDN2(),
          fetchFromCDN3()
        ]);
      behavior: "Only rejects if ALL promises reject"

  error_handling:
    catch_method:
      example: |
        promise
          .then(result => process(result))
          .catch(error => {
            console.error('Error:', error);
            return fallbackValue;
          });

    second_then_argument:
      example: |
        promise.then(
          result => handleSuccess(result),
          error => handleError(error)
        );
      note: "Only catches errors from the promise, not from handleSuccess"

# Async/Await Patterns
async_await_patterns:
  basic:
    example: |
      async function fetchUser(id) {
        const response = await fetch(`/api/users/${id}`);
        if (!response.ok) {
          throw new Error('User not found');
        }
        return response.json();
      }

  error_handling:
    try_catch:
      example: |
        async function getData() {
          try {
            const result = await riskyOperation();
            return result;
          } catch (error) {
            console.error('Failed:', error);
            return defaultValue;
          } finally {
            cleanup();
          }
        }

    wrapper_function:
      example: |
        const safeAsync = (fn) => async (...args) => {
          try {
            return [null, await fn(...args)];
          } catch (error) {
            return [error, null];
          }
        };

        const [error, data] = await safeAsync(fetchUser)(123);

  parallel_with_await:
    sequential_bad:
      example: |
        // BAD - runs sequentially
        const users = await fetchUsers();
        const posts = await fetchPosts();
      problem: "Second await waits for first to complete"

    parallel_good:
      example: |
        // GOOD - runs in parallel
        const [users, posts] = await Promise.all([
          fetchUsers(),
          fetchPosts()
        ]);

  loop_patterns:
    sequential_loop:
      example: |
        async function processSequentially(items) {
          for (const item of items) {
            await process(item);  // One at a time
          }
        }
      use_case: "When order matters or rate limiting needed"

    parallel_loop:
      example: |
        async function processParallel(items) {
          await Promise.all(items.map(item => process(item)));
        }
      use_case: "When independent and order doesn't matter"

    controlled_parallel:
      example: |
        async function processWithLimit(items, limit = 5) {
          const results = [];
          for (let i = 0; i < items.length; i += limit) {
            const batch = items.slice(i, i + limit);
            const batchResults = await Promise.all(
              batch.map(item => process(item))
            );
            results.push(...batchResults);
          }
          return results;
        }
      use_case: "Rate limiting, resource management"

# Advanced Patterns
advanced_patterns:
  retry:
    example: |
      async function retry(fn, maxAttempts = 3, delay = 1000) {
        for (let attempt = 1; attempt <= maxAttempts; attempt++) {
          try {
            return await fn();
          } catch (error) {
            if (attempt === maxAttempts) throw error;
            await sleep(delay * attempt);  // Exponential backoff
          }
        }
      }

  timeout:
    example: |
      function withTimeout(promise, ms) {
        const timeout = new Promise((_, reject) =>
          setTimeout(() => reject(new Error('Timeout')), ms)
        );
        return Promise.race([promise, timeout]);
      }

  cancellation:
    example: |
      function cancellablePromise(promise) {
        let isCancelled = false;

        const wrapped = new Promise((resolve, reject) => {
          promise.then(
            value => isCancelled ? reject({ cancelled: true }) : resolve(value),
            error => isCancelled ? reject({ cancelled: true }) : reject(error)
          );
        });

        return {
          promise: wrapped,
          cancel: () => { isCancelled = true; }
        };
      }

  debounce_async:
    example: |
      function debounceAsync(fn, delay) {
        let timeoutId;
        let pendingPromise = null;

        return async function(...args) {
          return new Promise((resolve, reject) => {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(async () => {
              try {
                resolve(await fn.apply(this, args));
              } catch (error) {
                reject(error);
              }
            }, delay);
          });
        };
      }

  queue:
    example: |
      class AsyncQueue {
        constructor() {
          this.queue = [];
          this.processing = false;
        }

        async add(fn) {
          return new Promise((resolve, reject) => {
            this.queue.push({ fn, resolve, reject });
            this.process();
          });
        }

        async process() {
          if (this.processing) return;
          this.processing = true;

          while (this.queue.length > 0) {
            const { fn, resolve, reject } = this.queue.shift();
            try {
              resolve(await fn());
            } catch (error) {
              reject(error);
            }
          }

          this.processing = false;
        }
      }

# Common Pitfalls
pitfalls:
  forgotten_await:
    bad: "const result = asyncFunction();"
    good: "const result = await asyncFunction();"
    issue: "Returns Promise, not result"

  foreach_await:
    bad: |
      items.forEach(async (item) => {
        await process(item);  // Doesn't wait!
      });
    good: |
      for (const item of items) {
        await process(item);
      }
    issue: "forEach doesn't wait for async callbacks"

  swallowed_errors:
    bad: |
      async function() {
        doSomething();  // Missing await - errors swallowed
      }
    good: |
      async function() {
        await doSomething();  // Errors will propagate
      }

  unhandled_rejection:
    bad: "asyncFunction();  // No .catch or try/catch"
    good: "asyncFunction().catch(console.error);"
    issue: "Unhandled promise rejection warning"

# Best Practices
best_practices:
  - rule: "Always handle errors with try/catch or .catch()"
    reason: "Prevent unhandled rejections"

  - rule: "Use Promise.all for parallel operations"
    reason: "Better performance than sequential await"

  - rule: "Avoid mixing callbacks and Promises"
    reason: "Consistency and readability"

  - rule: "Use async/await over .then() chains"
    reason: "More readable, easier debugging"

  - rule: "Don't forget await before async function calls"
    reason: "Get actual value, not Promise"

  - rule: "Use AbortController for cancellable requests"
    reason: "Clean resource management"
